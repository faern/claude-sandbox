#!/usr/bin/env bash
#
# https://github.com/faern/claude-sandbox
#
# This is a rootless podman container based coding agent sandbox focusing on being simple and secure
# without extra bells and whistles.
#
# This will prevent the agent from reading or modifying files outside of the working directory
# you start it in. This also isolates the agent from the host machine in terms of /proc, the list of
# processes on the host and more.
#
# Copy this script (or symlink it) to ~/.local/bin/ and use directly!
# Invoke as "claude-sandbox" or "opencode-sandbox" (via symlink or rename).
# See `<name>-sandbox --help` for more.
#
# Copyright (C) 2025 Linus Färnstrand
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
set -euo pipefail

# ===========================================================================
# Agent dispatch — set tool-specific config based on how the script was invoked
# ===========================================================================

readonly CONTAINERFILE_NAME="Containerfile.agent"
readonly GLOBAL_CONFIG_DIR="$HOME/.config/agent-sandbox"

case "$(basename "$0")" in
    claude-sandbox)
        AGENT_NAME="claude"
        AGENT_DISPLAY_NAME="Claude Code"
        SANDBOX_NAME="claude-sandbox"
        AUTOUPDATE_ENV="DISABLE_AUTOUPDATER"
        INSTALL_URL="https://claude.ai/install.sh"
        ENV_PATTERN='^ANTHROPIC_'
        EXTRA_ENV_VARS=()
        YOLO_FLAG="--dangerously-skip-permissions"
        ;;
    opencode-sandbox)
        AGENT_NAME="opencode"
        AGENT_DISPLAY_NAME="OpenCode"
        SANDBOX_NAME="opencode-sandbox"
        AUTOUPDATE_ENV="OPENCODE_DISABLE_AUTOUPDATE"
        INSTALL_URL="https://opencode.ai/install"
        ENV_PATTERN='^(ANTHROPIC_|OPENAI_|GEMINI_|GROQ_|AWS_|AZURE_|OPENCODE_|GOOGLE_|GITLAB_|CLOUDFLARE_)'
        EXTRA_ENV_VARS=(GITHUB_TOKEN)
        YOLO_FLAG=""
        ;;
    *)
        echo "Error: unknown invocation name '$(basename "$0")'." >&2
        echo "Symlink or rename this script to 'claude-sandbox' or 'opencode-sandbox'." >&2
        exit 1
        ;;
esac

# Copies the right host config files into SANDBOX_DIR
prepare_agent_config() {
    case "$AGENT_NAME" in
        claude)
            if [[ -f "$HOME/.claude.json" ]]; then
                cp "$HOME/.claude.json" "$SANDBOX_DIR/claude.json"
            else
                echo '{}' > "$SANDBOX_DIR/claude.json"
            fi
            if [[ -d "$HOME/.claude" ]]; then
                cp -r "$HOME/.claude" "$SANDBOX_DIR/.claude"
            else
                mkdir -p "$SANDBOX_DIR/.claude"
            fi
            ;;
        opencode)
            if [[ -d "$HOME/.config/opencode" ]]; then
                cp -r "$HOME/.config/opencode" "$SANDBOX_DIR/config-opencode"
            else
                mkdir -p "$SANDBOX_DIR/config-opencode"
            fi
            if [[ -d "$HOME/.local/share/opencode" ]]; then
                cp -r "$HOME/.local/share/opencode" "$SANDBOX_DIR/share-opencode"
            else
                mkdir -p "$SANDBOX_DIR/share-opencode"
            fi
            ;;
    esac
}

# Adds the right -v mount flags for agent config files
build_agent_mounts() {
    case "$AGENT_NAME" in
        claude)
            RUN_ARGS+=(-v "$SANDBOX_DIR/claude.json:$HOME/.claude.json:rw,z")
            RUN_ARGS+=(-v "$SANDBOX_DIR/.claude:$HOME/.claude:rw,z")
            ;;
        opencode)
            RUN_ARGS+=(-v "$SANDBOX_DIR/config-opencode:$HOME/.config/opencode:rw,z")
            RUN_ARGS+=(-v "$SANDBOX_DIR/share-opencode:$HOME/.local/share/opencode:rw,z")
            ;;
    esac
}

# Returns extra mkdir -p paths needed in the containerfile
containerfile_extra_dirs() {
    case "$AGENT_NAME" in
        claude)  ;;
        opencode) echo " ${user_home}/.config/opencode ${user_home}/.local/share/opencode" ;;
    esac
}

# --- Terminal styles ---
readonly COLOR_VERBOSE="\033[33m"
readonly COLOR_DEEMPHASIZE="\033[2m"
readonly COLOR_RESET="\033[0m"


# Project Containerfile: replaces default containerfile (must include FROM).
# Project overrides global (no concatenation).
readonly PROJECT_CONTAINERFILE="$PWD/$CONTAINERFILE_NAME"
readonly GLOBAL_CONTAINERFILE="$GLOBAL_CONFIG_DIR/$CONTAINERFILE_NAME"

# Content addressable versions of configs are stored here. Configs not
# in here will not be parsed until manually approved.
readonly TRUSTED_CONFIGS_DIR="$GLOBAL_CONFIG_DIR/trusted-configs"

usage() {
    cat <<EOF
Usage: $SANDBOX_NAME [OPTIONS] [-- ] [${AGENT_NAME^^}_ARGS...]

Run $AGENT_DISPLAY_NAME inside a rootless podman container.
The current working directory is bind-mounted into the container and is the
only host directory accessible (read-write by default, read-only with --read-only).

Options:
  --shell       Start an interactive shell instead of the agent
  --read-only   Mount project dir read-only
  --stateless   No project dir, ephemeral container
  --rebuild     Force image rebuild
  -c, --cleanup List/remove old sandbox images
  -v, --verbose Print debug info (config sources, image tag, rebuild reason)
  --agent host|install|none
                How to provide $AGENT_NAME in the container (default: host).
                host:    Mount host $AGENT_NAME binary into container (read-only)
                install: Install $AGENT_NAME into container during image build.
                none:    Don't provide $AGENT_NAME at all. You are expected to
                         install it via the containerfile
  --cap-add CAP Add a Linux capability (repeatable). By default,
                CAP_SETUID, CAP_SETGID, and CAP_DAC_READ_SEARCH are
                already enabled (required for sudo).
  --yolo        Pass --dangerously-skip-permissions to $AGENT_NAME (claude-sandbox only)
  -h, --help    Show this help

Arguments after -- are passed through to $AGENT_NAME.

Configuration:
  Customize the sandbox via an optional $CONTAINERFILE_NAME in the
  project root. Global default goes in ~/.config/$SANDBOX_NAME/ (project
  overrides global). Project configs are trust-gated — you'll be prompted
  before they take effect.

  $CONTAINERFILE_NAME Custom containerfile. Must include a FROM line.
                                $SANDBOX_NAME splits it at the first FROM and
                                injects user creation + ARGs (USERNAME, USER_HOME,
                                USER_UID, USER_GID) right after FROM. Your
                                commands can use USER \${USERNAME} to run as the
                                sandbox user. After your file, sudo setup, PATH
                                config, and optional $AGENT_NAME install are appended.
                                Without this file, Ubuntu 24.04 with git, curl,
                                ripgrep, fd-find, jq, build-essential, and sudo.

  Images are tagged by config hash — different configs build separate images.
  Rebuild triggers automatically when configs change, or force with --rebuild.

Environment variables:
  SANDBOX_CONTAINERFILE         Override containerfile path (must exist, skips discovery)
EOF
    exit 0
}

# --- Arg parsing ---
OPT_READ_ONLY=0
OPT_STATELESS=0
OPT_REBUILD=0
OPT_CLEANUP=0
OPT_VERBOSE=0
OPT_SHELL=0
OPT_AGENT_SOURCE=host
OPT_AGENT_EXPLICIT=0
AGENT_ARGS=()
CAP_ADD_ARGS=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --shell)      OPT_SHELL=1; shift ;;
        --read-only)  OPT_READ_ONLY=1; shift ;;
        --stateless)  OPT_STATELESS=1; shift ;;
        --rebuild)    OPT_REBUILD=1; shift ;;
        -c|--cleanup) OPT_CLEANUP=1; shift ;;
        -v|--verbose) OPT_VERBOSE=1; shift ;;
        --yolo)
            [[ -n "$YOLO_FLAG" ]] && AGENT_ARGS+=("$YOLO_FLAG")
            shift
            ;;
        --agent)
            case "${2:-}" in
                host|install|none) OPT_AGENT_SOURCE="$2"; OPT_AGENT_EXPLICIT=1; shift 2 ;;
                *) echo "Error: --agent must be host, install, or none" >&2; exit 1 ;;
            esac
            ;;
        -h|--help)    usage ;;
        --cap-add)    CAP_ADD_ARGS+=(--cap-add "$2"); shift 2 ;;
        --)           shift; AGENT_ARGS+=("$@"); break ;;
        *)            echo "Unknown option: $1" >&2; echo "Use -- to pass arguments to $AGENT_NAME." >&2; exit 1 ;;
    esac
done
readonly OPT_READ_ONLY OPT_STATELESS OPT_REBUILD OPT_CLEANUP OPT_VERBOSE OPT_SHELL OPT_AGENT_EXPLICIT
readonly AGENT_ARGS CAP_ADD_ARGS

verbose() { [[ $OPT_VERBOSE -eq 1 ]] && echo -e "${COLOR_VERBOSE}[#] $*${COLOR_RESET}" >&2 || true; }

# ===========================================================================
# Function definitions
# ===========================================================================

# --- Config trust gate ---
# Verify generated Containerfile content is trusted before building. Prompts user
# interactively if not. Trust is keyed on SHA256 of the full generated Containerfile.
ensure_config_trusted() {
    local content="$1"

    local hash
    hash=$(echo -n "$content" | sha256sum | cut -c1-64)

    mkdir -p -m 0700 "$TRUSTED_CONFIGS_DIR"
    if [[ -f "$TRUSTED_CONFIGS_DIR/$hash" ]]; then
        verbose "Config trusted ($hash)"
        return 0
    fi

    echo "Untrusted Containerfile (source: $SANDBOX_CONTAINERFILE)" >&2
    echo "---" >&2
    echo -ne "${COLOR_DEEMPHASIZE}" >&2
    echo "$content" >&2
    echo -e "${COLOR_RESET}" >&2
    echo "---" >&2
    local answer
    read -rp "Trust this config? [y/N] " answer
    if [[ "$answer" =~ ^[Yy]$ ]]; then
        echo "$content" > "$TRUSTED_CONFIGS_DIR/$hash"
        verbose "Stored trusted config: $TRUSTED_CONFIGS_DIR/$hash"
        echo "Config trusted." >&2
    else
        echo "Aborting." >&2
        exit 1
    fi
}

# Returns 0 (true) if the image should be (re)built. Triggers on:
# --rebuild flag or image missing (config changes produce different IMAGE_TAG).
needs_rebuild() {
    if [[ $OPT_REBUILD -eq 1 ]]; then
        verbose "Rebuild reason: --rebuild flag"
        return 0
    fi

    if ! podman image exists "$IMAGE_TAG" 2>/dev/null; then
        verbose "Rebuild reason: image $IMAGE_TAG does not exist"
        return 0
    fi

    verbose "Image is up to date, no rebuild needed"
    return 1
}

# Generate a Containerfile from project containerfile (or default) + sandbox suffix.
generate_containerfile() {
    local username
    username=$(whoami)
    local user_uid
    user_uid=$(id -u)
    local user_gid
    user_gid=$(id -g)
    local user_home="$HOME"

    # Injected right after the first FROM line: ARG declarations + user creation.
    # Placing ARGs after FROM makes them available to preamble commands directly
    # (pre-FROM ARGs are only usable in FROM instructions themselves).
    local post_from_block
    post_from_block=$(cat <<POSTFROM_EOF

ARG USERNAME=${username}
ARG USER_HOME=${user_home}
ARG USER_UID=${user_uid}
ARG USER_GID=${user_gid}

# Create user matching host UID/GID
RUN existing_user=\$(awk -F: '\$3 == "${user_uid}" {print \$1}' /etc/passwd) \\
    && [ -n "\$existing_user" ] && userdel -r "\$existing_user" 2>/dev/null || true \\
    ; existing_group=\$(awk -F: '\$3 == "${user_gid}" {print \$1}' /etc/group) \\
    && [ -n "\$existing_group" ] && groupdel "\$existing_group" 2>/dev/null || true \\
    ; groupadd --gid ${user_gid} ${username} \\
    && useradd --uid ${user_uid} --gid ${user_gid} --home-dir ${user_home} -m ${username}
POSTFROM_EOF
    )

    # --- Project-provided or default containerfile ---
    if [[ -n "$SANDBOX_CONTAINERFILE" ]]; then
        local preamble
        preamble=$(cat "$SANDBOX_CONTAINERFILE")
        # Split at first FROM line: output everything up to and including it,
        # inject user creation, then output the rest.
        local from_line
        from_line=$(echo "$preamble" | awk '/^[Ff][Rr][Oo][Mm] /{print NR; exit}')
        if [[ -z "$from_line" ]]; then
            echo "Error: containerfile has no FROM line: $SANDBOX_CONTAINERFILE" >&2
            return 1
        fi
        echo "$preamble" | head -n "$from_line"
        echo "$post_from_block"
        local total_lines
        total_lines=$(echo "$preamble" | wc -l)
        if [[ "$from_line" -lt "$total_lines" ]]; then
            echo "$preamble" | tail -n +$((from_line + 1))
        fi
    else
        echo "FROM ubuntu:24.04"
        echo "$post_from_block"
        cat <<'PREAMBLE_EOF'

RUN apt-get update \
    && DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
        git curl ca-certificates ripgrep fd-find jq build-essential sudo \
    && rm -rf /var/lib/apt/lists/*
PREAMBLE_EOF
    fi

    local extra_dirs
    extra_dirs=$(containerfile_extra_dirs)

    # --- Always appended (distro-agnostic) ---
    cat <<SUFFIX_EOF

# Reset to root (containerfile may have switched USER)
USER root

# Grant passwordless sudo if sudo is installed
RUN if command -v sudo >/dev/null 2>&1; then \\
        echo "${username} ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/${username} \\
        && chmod 0440 /etc/sudoers.d/${username}; \\
    fi

# Become the user, instead of root
USER ${username}

RUN mkdir -p ${user_home}/.local/bin ${user_home}/.local/share${extra_dirs}
ENV PATH="${user_home}/.local/bin:\${PATH}"

SUFFIX_EOF

    if [[ "$OPT_AGENT_SOURCE" == "install" ]]; then
        cat <<INSTALL_EOF

RUN curl -fsSL ${INSTALL_URL} | bash
INSTALL_EOF
    fi
}

# Per-sandbox isolated agent config.
# Each sandbox gets a fresh copy of host agent config in a temp dir.
# Prevents a compromised sandbox from poisoning host config or other sandboxes.
prepare_sandbox_home() {
    local container_name="$1"
    # SANDBOX_DIR is intentionally global — used by the EXIT trap
    SANDBOX_DIR=$(mktemp -d "${XDG_RUNTIME_DIR:-/tmp}/${container_name}-XXXXXX")
    trap 'rm -rf "$SANDBOX_DIR"' EXIT

    prepare_agent_config
    verbose "Sandbox home: $SANDBOX_DIR"
}

# Appends mount flags directly to RUN_ARGS array (avoids word-splitting issues with paths).
build_mounts() {
    build_agent_mounts

    # When not in stateless mode, mount the current working directory
    if [[ $OPT_STATELESS -eq 0 ]]; then
        local mount_mode="rw"
        [[ $OPT_READ_ONLY -eq 1 ]] && mount_mode="ro"
        RUN_ARGS+=(-v "$PWD:$PWD:${mount_mode},z")
    fi
}

# ===========================================================================
# Execution
# ===========================================================================

# --- Check podman ---
if ! command -v podman &>/dev/null; then
    echo "Error: podman not found. Install podman first." >&2
    exit 1
fi

# --- Cleanup subcommand ---
if [[ $OPT_CLEANUP -eq 1 ]]; then
    if ! command -v fzf &>/dev/null; then
        echo "Error: fzf not found. Install fzf for interactive cleanup." >&2
        exit 1
    fi

    images=$(podman images --filter "reference=$SANDBOX_NAME:*" --format "{{.Repository}}:{{.Tag}}\t{{.ID}}\t{{.Size}}\t{{.CreatedSince}}" 2>/dev/null || true)
    if [[ -z "$images" ]]; then
        echo "No sandbox images found."
        exit 0
    fi

    fzf_lines=""
    while IFS=$'\t' read -r name id size created; do
        fzf_lines+="$(printf "%-30s  %-14s  %-10s  %s" "$name" "$id" "$size" "$created")"$'\n'
    done <<< "$images"

    selected=$(echo "$fzf_lines" | fzf --multi --header="Select images to remove (TAB to multi-select, ENTER to confirm)" --reverse) || exit 0

    while IFS= read -r line; do
        image_name=$(echo "$line" | awk '{print $1}')
        [[ -z "$image_name" ]] && continue
        echo "Removing $image_name..."
        podman rmi "$image_name"
    done <<< "$selected"
    echo "Done."
    exit 0
fi

# --- Project containerfile discovery ---
# SANDBOX_CONTAINERFILE env override takes precedence (must exist).
# Otherwise: project overrides global, no concatenation.
if [[ -n "${SANDBOX_CONTAINERFILE:-}" ]]; then
    if [[ ! -f "$SANDBOX_CONTAINERFILE" ]]; then
        echo "Error: SANDBOX_CONTAINERFILE does not exist: $SANDBOX_CONTAINERFILE" >&2
        exit 1
    fi
    verbose "Containerfile: $SANDBOX_CONTAINERFILE (env override)"
elif [[ -f "$PROJECT_CONTAINERFILE" ]]; then
    SANDBOX_CONTAINERFILE="$PROJECT_CONTAINERFILE"
    verbose "Project containerfile: $PROJECT_CONTAINERFILE (project)"
elif [[ -f "$GLOBAL_CONTAINERFILE" ]]; then
    SANDBOX_CONTAINERFILE="$GLOBAL_CONTAINERFILE"
    verbose "Project containerfile: $GLOBAL_CONTAINERFILE (global)"
else
    SANDBOX_CONTAINERFILE=""
    verbose "No project containerfile, using default Ubuntu base"
fi
readonly SANDBOX_CONTAINERFILE

# --- CWD safety ---
if [[ $OPT_STATELESS -eq 0 ]]; then
    if [[ "$PWD" == "$HOME" ]]; then
        echo "Warning: running in \$HOME — this will mount your entire home directory." >&2
        read -rp "Continue? [y/N] " answer
        [[ "$answer" =~ ^[Yy]$ ]] || exit 1
    elif [[ "$PWD" != "$HOME"/* ]]; then
        echo "Warning: running outside \$HOME ($PWD)." >&2
        read -rp "Continue? [y/N] " answer
        [[ "$answer" =~ ^[Yy]$ ]] || exit 1
    fi
fi

# --- Auto-fallback: --agent host (default) with no host binary -> install ---
if [[ "$OPT_AGENT_SOURCE" == "host" && "$OPT_AGENT_EXPLICIT" -eq 0 ]]; then
    if ! command -v "$AGENT_NAME" &>/dev/null; then
        echo "Note: $AGENT_NAME not found on host; falling back to --agent install" >&2
        OPT_AGENT_SOURCE=install
    fi
fi
readonly OPT_AGENT_SOURCE

# --- Generate Containerfile, derive image tag ---
GENERATED_CONTAINERFILE="$(generate_containerfile)"
CONFIG_HASH=$(echo -n "$GENERATED_CONTAINERFILE" | sha256sum | cut -c1-10)
IMAGE_TAG="$SANDBOX_NAME:$CONFIG_HASH"
readonly GENERATED_CONTAINERFILE CONFIG_HASH IMAGE_TAG

# --- Trust-gate if custom containerfile in use ---
if [[ -n "$SANDBOX_CONTAINERFILE" ]]; then
    ensure_config_trusted "$GENERATED_CONTAINERFILE"
fi

# --- Build if needed ---
if needs_rebuild; then
    echo "Building sandbox image ($IMAGE_TAG)..."
    verbose "Generated Containerfile:\n$GENERATED_CONTAINERFILE"
    EMPTY_CTX=$(mktemp -d "${XDG_RUNTIME_DIR:-/tmp}/${SANDBOX_NAME}-ctx-XXXXXX")
    echo "$GENERATED_CONTAINERFILE" | podman build \
        -t "$IMAGE_TAG" \
        -f - \
        "$EMPTY_CTX"
    rm -rf "$EMPTY_CTX"
fi

# --- Container name ---
CONTAINER_NAME="${SANDBOX_NAME}-$$"
readonly CONTAINER_NAME
verbose "Container name: $CONTAINER_NAME"

prepare_sandbox_home "$CONTAINER_NAME"

# --- Working directory ---
if [[ $OPT_STATELESS -eq 1 ]]; then
    WORKDIR="$HOME"
else
    WORKDIR="$PWD"
fi
readonly WORKDIR

# --- Run ---
RUN_ARGS=(
    --rm
    --name "$CONTAINER_NAME"
    --userns="keep-id:uid=$(id -u),gid=$(id -g)"
    --label "${SANDBOX_NAME}.project-dir=$PWD"
    -e "${AUTOUPDATE_ENV}=1"
    # Enable websearch via EXA for OpenCode (https://opencode.ai/docs/tools#websearch)
    -e OPENCODE_ENABLE_EXA=1
    # Enable LSP support in OpenCode (https://opencode.ai/docs/tools#lsp-experimental)
    -e OPENCODE_EXPERIMENTAL_LSP_TOOL=true
    -e TERM=xterm-256color
    -e COLORTERM
    -w "$WORKDIR"
    -it
    # Mask /proc paths that leak host info (kernel symbols, memory, mounts, scheduler)
    --security-opt mask=/proc/kcore:/proc/kallsyms:/proc/config.gz:/proc/sched_debug:/proc/timer_list:/proc/self/mountinfo:/proc/1/mountinfo
    # Hide other users' processes in /proc
    --security-opt proc-opts=hidepid=2
    # Drop all capabilities, then re-add the minimum needed for sudo.
    # Users can add more with --cap-add.
    --cap-drop=ALL
    --cap-add CAP_SETUID
    --cap-add CAP_SETGID
    --cap-add CAP_DAC_READ_SEARCH
    "${CAP_ADD_ARGS[@]}"
)

# Pass through matching env vars to the container
while IFS='=' read -r -d '' name _; do
    RUN_ARGS+=(-e "$name")
done < <(env -0 | grep -z -E "$ENV_PATTERN")

# Pass through extra env vars if set
for var in "${EXTRA_ENV_VARS[@]}"; do
    if [[ -n "${!var:-}" ]]; then
        RUN_ARGS+=(-e "$var")
    fi
done

# Build mount args directly into RUN_ARGS (avoids word-splitting issues with paths)
build_mounts

# --- Resolve and mount host agent binary ---
if [[ "$OPT_AGENT_SOURCE" == "host" ]]; then
    AGENT_BIN=$(readlink -f "$(command -v "$AGENT_NAME")" 2>/dev/null) || true
    if [[ -z "$AGENT_BIN" || ! -f "$AGENT_BIN" ]]; then
        echo "Error: $AGENT_NAME binary not found in PATH." >&2
        exit 1
    fi
    verbose "$AGENT_DISPLAY_NAME binary: $AGENT_BIN"
    RUN_ARGS+=(-v "$AGENT_BIN:$HOME/.local/bin/$AGENT_NAME:ro,z")
fi

ENTRY_CMD="$AGENT_NAME"
[[ $OPT_SHELL -eq 1 ]] && ENTRY_CMD="bash"

verbose "podman run ${RUN_ARGS[*]} $IMAGE_TAG $ENTRY_CMD ${AGENT_ARGS[*]}"
exec podman run "${RUN_ARGS[@]}" "$IMAGE_TAG" "$ENTRY_CMD" "${AGENT_ARGS[@]}"
