#!/usr/bin/env bash
#
# https://github.com/faern/claude-sandbox
#
# This is a rootless podman container based Claude Code sandbox focusing on being simple and secure
# without extra bells and whistles.
#
# This will prevent claude from reading or modifying files outside of the working directory
# you start it in. This also isolates Claude from the host machine in terms of /proc, the list of
# processes on the host and more.
#
# Copy this script to ~/.local/bin/ and use directly! See `claude-sandbox --help` for more.
#
# Copyright (C) 2025 Linus Färnstrand
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
set -euo pipefail

# --- Terminal styles ---
readonly COLOR_VERBOSE="\033[33m"
readonly COLOR_DEEMPHASIZE="\033[2m"
readonly COLOR_RESET="\033[0m"

readonly GLOBAL_CONFIG_DIR="$HOME/.config/claude-sandbox"

# Project Containerfile preamble: replaces default preamble (must include FROM).
# Project overrides global (no concatenation).
readonly PROJECT_CONTAINERFILE="$PWD/.claude-sandbox.containerfile"
readonly GLOBAL_CONTAINERFILE="$GLOBAL_CONFIG_DIR/.claude-sandbox.containerfile"

# Content addressable versions of configs are stored here. Configs not
# in here will not be parsed until manually approved.
readonly TRUSTED_CONFIGS_DIR="$GLOBAL_CONFIG_DIR/trusted-configs"

usage() {
    cat <<'EOF'
Usage: claude-sandbox [OPTIONS] [-- ] [CLAUDE_ARGS...]

Run Claude Code inside a rootless podman container.
The current working directory is bind-mounted into the container and is the
only host directory accessible (read-write by default, read-only with --read-only).

Options:
  --read-only   Mount project dir read-only
  --stateless   No project dir, ephemeral container
  --rebuild     Force image rebuild
  -c, --cleanup List/remove old sandbox images
  -v, --verbose Print debug info (config sources, image tag, rebuild reason)
  --claude host|install|none
                How to provide claude in the container (default: host).
                host:    Mount host claude binary into container (read-only)
                install: Install claude into container during image build.
                none:    Don't provide claude at all. You are expected to
                         install it via a container preamble
  --cap-add CAP Add a Linux capability (repeatable)
  -h, --help    Show this help

Arguments after -- are passed through to claude.

Configuration:
  Customize the sandbox via an optional .claude-sandbox.containerfile in the
  project root. Global default goes in ~/.config/claude-sandbox/ (project
  overrides global). Project configs are trust-gated — you'll be prompted
  before they take effect.

  .claude-sandbox.containerfile Replaces the default container preamble. Must
                                include a FROM line and install any needed tools.
                                Example (Fedora):
                                  FROM fedora:42
                                  RUN dnf install -y git curl ripgrep fd-find jq
                                Without this file, the default preamble uses
                                Ubuntu 24.04 with git, curl, ripgrep, fd-find,
                                jq, build-essential, and sudo pre-installed.

  Images are tagged by config hash — different configs build separate images.
  Rebuild triggers automatically when configs change, or force with --rebuild.

Environment variables:
  SANDBOX_CONTAINERFILE         Override containerfile preamble path (must exist, skips discovery)
EOF
    exit 0
}

# --- Arg parsing ---
OPT_READ_ONLY=0
OPT_STATELESS=0
OPT_REBUILD=0
OPT_CLEANUP=0
OPT_VERBOSE=0
OPT_CLAUDE_SOURCE=host
CLAUDE_ARGS=()
CAP_ADD_ARGS=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --read-only)  OPT_READ_ONLY=1; shift ;;
        --stateless)  OPT_STATELESS=1; shift ;;
        --rebuild)    OPT_REBUILD=1; shift ;;
        -c|--cleanup) OPT_CLEANUP=1; shift ;;
        -v|--verbose) OPT_VERBOSE=1; shift ;;
        --claude)
            case "${2:-}" in
                host|install|none) OPT_CLAUDE_SOURCE="$2"; shift 2 ;;
                *) echo "Error: --claude must be host, install, or none" >&2; exit 1 ;;
            esac
            ;;
        -h|--help)    usage ;;
        --cap-add)    CAP_ADD_ARGS+=(--cap-add "$2"); shift 2 ;;
        --)           shift; CLAUDE_ARGS+=("$@"); break ;;
        *)            echo "Unknown option: $1" >&2; echo "Use -- to pass arguments to claude." >&2; exit 1 ;;
    esac
done
readonly OPT_READ_ONLY OPT_STATELESS OPT_REBUILD OPT_CLEANUP OPT_VERBOSE OPT_CLAUDE_SOURCE
readonly CLAUDE_ARGS CAP_ADD_ARGS

verbose() { [[ $OPT_VERBOSE -eq 1 ]] && echo -e "${COLOR_VERBOSE}[#] $*${COLOR_RESET}" >&2 || true; }

# ===========================================================================
# Function definitions
# ===========================================================================

# --- Config trust gate ---
# Verify generated Containerfile content is trusted before building. Prompts user
# interactively if not. Trust is keyed on SHA256 of the full generated Containerfile.
ensure_config_trusted() {
    local content="$1"

    local hash
    hash=$(echo -n "$content" | sha256sum | cut -c1-64)

    mkdir -p -m 0700 "$TRUSTED_CONFIGS_DIR"
    if [[ -f "$TRUSTED_CONFIGS_DIR/$hash" ]]; then
        verbose "Config trusted ($hash)"
        return 0
    fi

    echo "Untrusted Containerfile (preamble: $SANDBOX_CONTAINERFILE)" >&2
    echo "---" >&2
    echo -ne "${COLOR_DEEMPHASIZE}" >&2
    echo "$content" >&2
    echo -e "${COLOR_RESET}" >&2
    echo "---" >&2
    local answer
    read -rp "Trust this config? [y/N] " answer
    if [[ "$answer" =~ ^[Yy]$ ]]; then
        echo "$content" > "$TRUSTED_CONFIGS_DIR/$hash"
        verbose "Stored trusted config: $TRUSTED_CONFIGS_DIR/$hash"
        echo "Config trusted." >&2
    else
        echo "Aborting." >&2
        exit 1
    fi
}

# Returns 0 (true) if the image should be (re)built. Triggers on:
# --rebuild flag or image missing (config changes produce different IMAGE_TAG).
needs_rebuild() {
    if [[ $OPT_REBUILD -eq 1 ]]; then
        verbose "Rebuild reason: --rebuild flag"
        return 0
    fi

    if ! podman image exists "$IMAGE_TAG" 2>/dev/null; then
        verbose "Rebuild reason: image $IMAGE_TAG does not exist"
        return 0
    fi

    verbose "Image is up to date, no rebuild needed"
    return 1
}

# Generate a Containerfile from project containerfile preamble (or default) + distro-agnostic suffix.
generate_containerfile() {
    local username
    username=$(whoami)
    local user_uid
    user_uid=$(id -u)
    local user_gid
    user_gid=$(id -g)
    local user_home="$HOME"

    cat <<ARGS_EOF
# First define user arguments, so that the project provided preamble can use it
# NOTE: ARGs defined before the FROM instructions must be re-declared after the FROM
# instruction. To use these in a project preamble re-declare the ones you need
# like, the following (no value specified):
# ARG USER_HOME

ARG USERNAME=${username}
ARG USER_HOME=${user_home}
ARG USER_UID=${user_uid}
ARG USER_GID=${user_gid}

ARGS_EOF

    # --- Preamble: project-provided or default ---
    if [[ -n "$SANDBOX_CONTAINERFILE" ]]; then
        echo "# === PROJECT PREAMBLE START ==="
        cat "$SANDBOX_CONTAINERFILE"
    else
        cat <<'PREAMBLE_EOF'
# === DEFAULT PREAMBLE START ===
FROM ubuntu:24.04

RUN apt-get update \
    && DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
        git curl ca-certificates ripgrep fd-find jq build-essential sudo \
    && rm -rf /var/lib/apt/lists/*
PREAMBLE_EOF
    fi

    # --- Always appended (distro-agnostic) ---
    cat <<SUFFIX_EOF
# === PREAMBLE END ===

# Create user matching host UID/GID
RUN existing_user=\$(awk -F: '\$3 == "${user_uid}" {print \$1}' /etc/passwd) \\
    && [ -n "\$existing_user" ] && userdel -r "\$existing_user" 2>/dev/null || true \\
    ; existing_group=\$(awk -F: '\$3 == "${user_gid}" {print \$1}' /etc/group) \\
    && [ -n "\$existing_group" ] && groupdel "\$existing_group" 2>/dev/null || true \\
    ; groupadd --gid ${user_gid} ${username} \\
    && useradd --uid ${user_uid} --gid ${user_gid} --home-dir ${user_home} -m ${username}

# Grant passwordless sudo if sudo is installed
RUN if command -v sudo >/dev/null 2>&1; then \\
        echo "${username} ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/${username} \\
        && chmod 0440 /etc/sudoers.d/${username}; \\
    fi

# Become the user, instead of root
USER ${username}

RUN mkdir -p ${user_home}/.local/bin ${user_home}/.local/share
ENV PATH="${user_home}/.local/bin:\${PATH}"

SUFFIX_EOF

    if [[ "$OPT_CLAUDE_SOURCE" == "install" ]]; then
        cat <<'INSTALL_EOF'

RUN curl -fsSL https://claude.ai/install.sh | bash
INSTALL_EOF
    fi
}

# Per-sandbox isolated ~/.claude.
# Each sandbox gets a fresh copy of host claude config in a temp dir.
# Prevents a compromised sandbox from poisoning host config or other sandboxes.
prepare_sandbox_home() {
    local container_name="$1"
    # SANDBOX_DIR is intentionally global — used by the EXIT trap
    SANDBOX_DIR=$(mktemp -d "${XDG_RUNTIME_DIR:-/tmp}/${container_name}-XXXXXX")
    trap 'rm -rf "$SANDBOX_DIR"' EXIT

    if [[ -f "$HOME/.claude.json" ]]; then
        cp "$HOME/.claude.json" "$SANDBOX_DIR/claude.json"
    else
        echo '{}' > "$SANDBOX_DIR/claude.json"
    fi
    if [[ -d "$HOME/.claude" ]]; then
        cp -r "$HOME/.claude" "$SANDBOX_DIR/.claude"
    else
        mkdir -p "$SANDBOX_DIR/.claude"
    fi
    verbose "Sandbox home: $SANDBOX_DIR"
}

# Appends mount flags directly to RUN_ARGS array (avoids word-splitting issues with paths).
build_mounts() {
    RUN_ARGS+=(-v "$SANDBOX_DIR/claude.json:$HOME/.claude.json:rw,z")
    RUN_ARGS+=(-v "$SANDBOX_DIR/.claude:$HOME/.claude:rw,z")

    # When not in stateless mode, mount the current working directory
    if [[ $OPT_STATELESS -eq 0 ]]; then
        local mount_mode="rw"
        [[ $OPT_READ_ONLY -eq 1 ]] && mount_mode="ro"
        RUN_ARGS+=(-v "$PWD:$PWD:${mount_mode},z")
    fi
}

# ===========================================================================
# Execution
# ===========================================================================

# --- Check podman ---
if ! command -v podman &>/dev/null; then
    echo "Error: podman not found. Install podman first." >&2
    exit 1
fi

# --- Cleanup subcommand ---
if [[ $OPT_CLEANUP -eq 1 ]]; then
    if ! command -v fzf &>/dev/null; then
        echo "Error: fzf not found. Install fzf for interactive cleanup." >&2
        exit 1
    fi

    images=$(podman images --filter "reference=claude-sandbox:*" --format "{{.Repository}}:{{.Tag}}\t{{.ID}}\t{{.Size}}\t{{.CreatedSince}}" 2>/dev/null || true)
    if [[ -z "$images" ]]; then
        echo "No sandbox images found."
        exit 0
    fi

    fzf_lines=""
    while IFS=$'\t' read -r name id size created; do
        fzf_lines+="$(printf "%-30s  %-14s  %-10s  %s" "$name" "$id" "$size" "$created")"$'\n'
    done <<< "$images"

    selected=$(echo "$fzf_lines" | fzf --multi --header="Select images to remove (TAB to multi-select, ENTER to confirm)" --reverse) || exit 0

    while IFS= read -r line; do
        image_name=$(echo "$line" | awk '{print $1}')
        [[ -z "$image_name" ]] && continue
        echo "Removing $image_name..."
        podman rmi "$image_name"
    done <<< "$selected"
    echo "Done."
    exit 0
fi

# --- Project containerfile preamble discovery ---
# SANDBOX_CONTAINERFILE env override takes precedence (must exist).
# Otherwise: project overrides global, no concatenation.
if [[ -n "${SANDBOX_CONTAINERFILE:-}" ]]; then
    if [[ ! -f "$SANDBOX_CONTAINERFILE" ]]; then
        echo "Error: SANDBOX_CONTAINERFILE does not exist: $SANDBOX_CONTAINERFILE" >&2
        exit 1
    fi
    verbose "Containerfile: $SANDBOX_CONTAINERFILE (env override)"
elif [[ -f "$PROJECT_CONTAINERFILE" ]]; then
    SANDBOX_CONTAINERFILE="$PROJECT_CONTAINERFILE"
    verbose "Project containerfile: $PROJECT_CONTAINERFILE (project)"
elif [[ -f "$GLOBAL_CONTAINERFILE" ]]; then
    SANDBOX_CONTAINERFILE="$GLOBAL_CONTAINERFILE"
    verbose "Project containerfile: $GLOBAL_CONTAINERFILE (global)"
else
    SANDBOX_CONTAINERFILE=""
    verbose "No project containerfile, using default Ubuntu preamble"
fi
readonly SANDBOX_CONTAINERFILE

# --- CWD safety ---
if [[ $OPT_STATELESS -eq 0 ]]; then
    if [[ "$PWD" == "$HOME" ]]; then
        echo "Warning: running in \$HOME — this will mount your entire home directory." >&2
        read -rp "Continue? [y/N] " answer
        [[ "$answer" =~ ^[Yy]$ ]] || exit 1
    elif [[ "$PWD" != "$HOME"/* ]]; then
        echo "Warning: running outside \$HOME ($PWD)." >&2
        read -rp "Continue? [y/N] " answer
        [[ "$answer" =~ ^[Yy]$ ]] || exit 1
    fi
fi

# --- Generate Containerfile, derive image tag ---
GENERATED_CONTAINERFILE="$(generate_containerfile)"
CONFIG_HASH=$(echo -n "$GENERATED_CONTAINERFILE" | sha256sum | cut -c1-10)
IMAGE_TAG="claude-sandbox:$CONFIG_HASH"
readonly GENERATED_CONTAINERFILE CONFIG_HASH IMAGE_TAG

# --- Trust-gate if project containerfile in use ---
if [[ -n "$SANDBOX_CONTAINERFILE" && "$SANDBOX_CONTAINERFILE" != "$GLOBAL_CONTAINERFILE" ]]; then
    ensure_config_trusted "$GENERATED_CONTAINERFILE"
fi

# --- Build if needed ---
if needs_rebuild; then
    echo "Building sandbox image ($IMAGE_TAG)..."
    verbose "Generated Containerfile:\n$GENERATED_CONTAINERFILE"
    EMPTY_CTX=$(mktemp -d "${XDG_RUNTIME_DIR:-/tmp}/claude-sandbox-ctx-XXXXXX")
    echo "$GENERATED_CONTAINERFILE" | podman build \
        -t "$IMAGE_TAG" \
        -f - \
        "$EMPTY_CTX"
    rm -rf "$EMPTY_CTX"
fi

# --- Container name ---
if [[ $OPT_STATELESS -eq 1 ]]; then
    CONTAINER_NAME="claude-sandbox-stateless-$$"
else
    DIR_HASH=$(echo -n "$PWD" | sha256sum | cut -c1-10)
    CONTAINER_NAME="claude-sandbox-${DIR_HASH}"
fi
readonly CONTAINER_NAME
verbose "Container name: $CONTAINER_NAME"

prepare_sandbox_home "$CONTAINER_NAME"

# --- Working directory ---
if [[ $OPT_STATELESS -eq 1 ]]; then
    WORKDIR="$HOME"
else
    WORKDIR="$PWD"
fi
readonly WORKDIR

# --- Run ---
RUN_ARGS=(
    --rm
    --name "$CONTAINER_NAME"
    --userns="keep-id:uid=$(id -u),gid=$(id -g)"
    --label "claude-sandbox.project-dir=$PWD"
    -e DISABLE_AUTOUPDATER=1
    -e TERM=xterm-256color
    -e COLORTERM
    -w "$WORKDIR"
    -it
    # Mask /proc paths that leak host info (kernel symbols, memory, mounts, scheduler)
    --security-opt mask=/proc/kcore:/proc/kallsyms:/proc/config.gz:/proc/sched_debug:/proc/timer_list:/proc/self/mountinfo:/proc/1/mountinfo
    # Hide other users' processes in /proc
    --security-opt proc-opts=hidepid=2
    # Drop all capabilities; users can re-add with --cap-add
    --cap-drop=ALL
    "${CAP_ADD_ARGS[@]}"
)

# Pass through ANTHROPIC_* env vars to the container.
# This allows configuring claude in the sandbox in various ways
while IFS='=' read -r -d '' name _; do
    RUN_ARGS+=(-e "$name")
done < <(env -0 | grep -z '^ANTHROPIC_')

# Build mount args directly into RUN_ARGS (avoids word-splitting issues with paths)
build_mounts

# --- Resolve and mount host claude binary ---
if [[ "$OPT_CLAUDE_SOURCE" == "host" ]]; then
    CLAUDE_BIN=$(readlink -f "$(command -v claude)" 2>/dev/null) || true
    if [[ -z "$CLAUDE_BIN" || ! -f "$CLAUDE_BIN" ]]; then
        echo "Error: claude binary not found in PATH." >&2
        exit 1
    fi
    verbose "Claude binary: $CLAUDE_BIN"
    RUN_ARGS+=(-v "$CLAUDE_BIN:$HOME/.local/bin/claude:ro,z")
fi

verbose "podman run ${RUN_ARGS[*]} $IMAGE_TAG claude ${CLAUDE_ARGS[*]}"
exec podman run "${RUN_ARGS[@]}" "$IMAGE_TAG" claude "${CLAUDE_ARGS[@]}"
