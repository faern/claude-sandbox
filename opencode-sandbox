#!/usr/bin/env bash
#
# https://github.com/faern/claude-sandbox
#
# This is a rootless podman container based OpenCode sandbox focusing on being simple and secure
# without extra bells and whistles.
#
# This will prevent opencode from reading or modifying files outside of the working directory
# you start it in. This also isolates OpenCode from the host machine in terms of /proc, the list of
# processes on the host and more.
#
# Copy this script to ~/.local/bin/ and use directly! See `opencode-sandbox --help` for more.
#
# Copyright (C) 2025 Linus Färnstrand
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
set -euo pipefail

# --- Terminal styles ---
readonly COLOR_VERBOSE="\033[33m"
readonly COLOR_DEEMPHASIZE="\033[2m"
readonly COLOR_RESET="\033[0m"

readonly GLOBAL_CONFIG_DIR="$HOME/.config/opencode-sandbox"

# Project Containerfile: replaces default containerfile (must include FROM).
# Project overrides global (no concatenation).
readonly PROJECT_CONTAINERFILE="$PWD/.opencode-sandbox.containerfile"
readonly GLOBAL_CONTAINERFILE="$GLOBAL_CONFIG_DIR/.opencode-sandbox.containerfile"

# Content addressable versions of configs are stored here. Configs not
# in here will not be parsed until manually approved.
readonly TRUSTED_CONFIGS_DIR="$GLOBAL_CONFIG_DIR/trusted-configs"

usage() {
    cat <<'EOF'
Usage: opencode-sandbox [OPTIONS] [-- ] [OPENCODE_ARGS...]

Run OpenCode inside a rootless podman container.
The current working directory is bind-mounted into the container and is the
only host directory accessible (read-write by default, read-only with --read-only).

Options:
  --read-only   Mount project dir read-only
  --stateless   No project dir, ephemeral container
  --rebuild     Force image rebuild
  -c, --cleanup List/remove old sandbox images
  -v, --verbose Print debug info (config sources, image tag, rebuild reason)
  --opencode host|install|none
                How to provide opencode in the container (default: host).
                host:    Mount host opencode binary into container (read-only)
                install: Install opencode into container during image build.
                none:    Don't provide opencode at all. You are expected to
                         install it via the containerfile
  --cap-add CAP Add a Linux capability (repeatable)
  -h, --help    Show this help

Arguments after -- are passed through to opencode.

Configuration:
  Customize the sandbox via an optional .opencode-sandbox.containerfile in the
  project root. Global default goes in ~/.config/opencode-sandbox/ (project
  overrides global). Project configs are trust-gated — you'll be prompted
  before they take effect.

  .opencode-sandbox.containerfile Custom containerfile. Must include a FROM line.
                                opencode-sandbox splits it at the first FROM and
                                injects user creation + ARGs (USERNAME, USER_HOME,
                                USER_UID, USER_GID) right after FROM. Your
                                commands can use USER ${USERNAME} to run as the
                                sandbox user. After your file, sudo setup, PATH
                                config, and optional opencode install are appended.
                                Without this file, Ubuntu 24.04 with git, curl,
                                ripgrep, fd-find, jq, build-essential, and sudo.

  Images are tagged by config hash — different configs build separate images.
  Rebuild triggers automatically when configs change, or force with --rebuild.

Environment variables:
  SANDBOX_CONTAINERFILE         Override containerfile path (must exist, skips discovery)
EOF
    exit 0
}

# --- Arg parsing ---
OPT_READ_ONLY=0
OPT_STATELESS=0
OPT_REBUILD=0
OPT_CLEANUP=0
OPT_VERBOSE=0
OPT_OPENCODE_SOURCE=host
OPT_OPENCODE_EXPLICIT=0
OPENCODE_ARGS=()
CAP_ADD_ARGS=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --read-only)  OPT_READ_ONLY=1; shift ;;
        --stateless)  OPT_STATELESS=1; shift ;;
        --rebuild)    OPT_REBUILD=1; shift ;;
        -c|--cleanup) OPT_CLEANUP=1; shift ;;
        -v|--verbose) OPT_VERBOSE=1; shift ;;
        --opencode)
            case "${2:-}" in
                host|install|none) OPT_OPENCODE_SOURCE="$2"; OPT_OPENCODE_EXPLICIT=1; shift 2 ;;
                *) echo "Error: --opencode must be host, install, or none" >&2; exit 1 ;;
            esac
            ;;
        -h|--help)    usage ;;
        --cap-add)    CAP_ADD_ARGS+=(--cap-add "$2"); shift 2 ;;
        --)           shift; OPENCODE_ARGS+=("$@"); break ;;
        *)            echo "Unknown option: $1" >&2; echo "Use -- to pass arguments to opencode." >&2; exit 1 ;;
    esac
done
readonly OPT_READ_ONLY OPT_STATELESS OPT_REBUILD OPT_CLEANUP OPT_VERBOSE OPT_OPENCODE_EXPLICIT
readonly OPENCODE_ARGS CAP_ADD_ARGS

verbose() { [[ $OPT_VERBOSE -eq 1 ]] && echo -e "${COLOR_VERBOSE}[#] $*${COLOR_RESET}" >&2 || true; }

# ===========================================================================
# Function definitions
# ===========================================================================

# --- Config trust gate ---
# Verify generated Containerfile content is trusted before building. Prompts user
# interactively if not. Trust is keyed on SHA256 of the full generated Containerfile.
ensure_config_trusted() {
    local content="$1"

    local hash
    hash=$(echo -n "$content" | sha256sum | cut -c1-64)

    mkdir -p -m 0700 "$TRUSTED_CONFIGS_DIR"
    if [[ -f "$TRUSTED_CONFIGS_DIR/$hash" ]]; then
        verbose "Config trusted ($hash)"
        return 0
    fi

    echo "Untrusted Containerfile (source: $SANDBOX_CONTAINERFILE)" >&2
    echo "---" >&2
    echo -ne "${COLOR_DEEMPHASIZE}" >&2
    echo "$content" >&2
    echo -e "${COLOR_RESET}" >&2
    echo "---" >&2
    local answer
    read -rp "Trust this config? [y/N] " answer
    if [[ "$answer" =~ ^[Yy]$ ]]; then
        echo "$content" > "$TRUSTED_CONFIGS_DIR/$hash"
        verbose "Stored trusted config: $TRUSTED_CONFIGS_DIR/$hash"
        echo "Config trusted." >&2
    else
        echo "Aborting." >&2
        exit 1
    fi
}

# Returns 0 (true) if the image should be (re)built. Triggers on:
# --rebuild flag or image missing (config changes produce different IMAGE_TAG).
needs_rebuild() {
    if [[ $OPT_REBUILD -eq 1 ]]; then
        verbose "Rebuild reason: --rebuild flag"
        return 0
    fi

    if ! podman image exists "$IMAGE_TAG" 2>/dev/null; then
        verbose "Rebuild reason: image $IMAGE_TAG does not exist"
        return 0
    fi

    verbose "Image is up to date, no rebuild needed"
    return 1
}

# Generate a Containerfile from project containerfile (or default) + sandbox suffix.
generate_containerfile() {
    local username
    username=$(whoami)
    local user_uid
    user_uid=$(id -u)
    local user_gid
    user_gid=$(id -g)
    local user_home="$HOME"

    # Injected right after the first FROM line: ARG declarations + user creation.
    # Placing ARGs after FROM makes them available to preamble commands directly
    # (pre-FROM ARGs are only usable in FROM instructions themselves).
    local post_from_block
    post_from_block=$(cat <<POSTFROM_EOF

ARG USERNAME=${username}
ARG USER_HOME=${user_home}
ARG USER_UID=${user_uid}
ARG USER_GID=${user_gid}

# Create user matching host UID/GID
RUN existing_user=\$(awk -F: '\$3 == "${user_uid}" {print \$1}' /etc/passwd) \\
    && [ -n "\$existing_user" ] && userdel -r "\$existing_user" 2>/dev/null || true \\
    ; existing_group=\$(awk -F: '\$3 == "${user_gid}" {print \$1}' /etc/group) \\
    && [ -n "\$existing_group" ] && groupdel "\$existing_group" 2>/dev/null || true \\
    ; groupadd --gid ${user_gid} ${username} \\
    && useradd --uid ${user_uid} --gid ${user_gid} --home-dir ${user_home} -m ${username}
POSTFROM_EOF
    )

    # --- Project-provided or default containerfile ---
    if [[ -n "$SANDBOX_CONTAINERFILE" ]]; then
        local preamble
        preamble=$(cat "$SANDBOX_CONTAINERFILE")
        # Split at first FROM line: output everything up to and including it,
        # inject user creation, then output the rest.
        local from_line
        from_line=$(echo "$preamble" | awk '/^[Ff][Rr][Oo][Mm] /{print NR; exit}')
        if [[ -z "$from_line" ]]; then
            echo "Error: containerfile has no FROM line: $SANDBOX_CONTAINERFILE" >&2
            return 1
        fi
        echo "$preamble" | head -n "$from_line"
        echo "$post_from_block"
        local total_lines
        total_lines=$(echo "$preamble" | wc -l)
        if [[ "$from_line" -lt "$total_lines" ]]; then
            echo "$preamble" | tail -n +$((from_line + 1))
        fi
    else
        echo "FROM ubuntu:24.04"
        echo "$post_from_block"
        cat <<'PREAMBLE_EOF'

RUN apt-get update \
    && DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
        git curl ca-certificates ripgrep fd-find jq build-essential sudo \
    && rm -rf /var/lib/apt/lists/*
PREAMBLE_EOF
    fi

    # --- Always appended (distro-agnostic) ---
    cat <<SUFFIX_EOF

# Reset to root (containerfile may have switched USER)
USER root

# Grant passwordless sudo if sudo is installed
RUN if command -v sudo >/dev/null 2>&1; then \\
        echo "${username} ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/${username} \\
        && chmod 0440 /etc/sudoers.d/${username}; \\
    fi

# Become the user, instead of root
USER ${username}

RUN mkdir -p ${user_home}/.local/bin ${user_home}/.local/share ${user_home}/.config/opencode ${user_home}/.local/share/opencode
ENV PATH="${user_home}/.local/bin:\${PATH}"

SUFFIX_EOF

    if [[ "$OPT_OPENCODE_SOURCE" == "install" ]]; then
        cat <<'INSTALL_EOF'

RUN curl -fsSL https://opencode.ai/install | bash
INSTALL_EOF
    fi
}

# Per-sandbox isolated opencode config.
# Each sandbox gets a fresh copy of host opencode config in a temp dir.
# Prevents a compromised sandbox from poisoning host config or other sandboxes.
prepare_sandbox_home() {
    local container_name="$1"
    # SANDBOX_DIR is intentionally global — used by the EXIT trap
    SANDBOX_DIR=$(mktemp -d "${XDG_RUNTIME_DIR:-/tmp}/${container_name}-XXXXXX")
    trap 'rm -rf "$SANDBOX_DIR"' EXIT

    # Copy opencode config (~/.config/opencode/)
    if [[ -d "$HOME/.config/opencode" ]]; then
        cp -r "$HOME/.config/opencode" "$SANDBOX_DIR/config-opencode"
    else
        mkdir -p "$SANDBOX_DIR/config-opencode"
    fi

    # Copy opencode data (~/.local/share/opencode/) — contains auth.json + session data
    if [[ -d "$HOME/.local/share/opencode" ]]; then
        cp -r "$HOME/.local/share/opencode" "$SANDBOX_DIR/share-opencode"
    else
        mkdir -p "$SANDBOX_DIR/share-opencode"
    fi

    verbose "Sandbox home: $SANDBOX_DIR"
}

# Appends mount flags directly to RUN_ARGS array (avoids word-splitting issues with paths).
build_mounts() {
    RUN_ARGS+=(-v "$SANDBOX_DIR/config-opencode:$HOME/.config/opencode:rw,z")
    RUN_ARGS+=(-v "$SANDBOX_DIR/share-opencode:$HOME/.local/share/opencode:rw,z")

    # When not in stateless mode, mount the current working directory
    if [[ $OPT_STATELESS -eq 0 ]]; then
        local mount_mode="rw"
        [[ $OPT_READ_ONLY -eq 1 ]] && mount_mode="ro"
        RUN_ARGS+=(-v "$PWD:$PWD:${mount_mode},z")
    fi
}

# ===========================================================================
# Execution
# ===========================================================================

# --- Check podman ---
if ! command -v podman &>/dev/null; then
    echo "Error: podman not found. Install podman first." >&2
    exit 1
fi

# --- Cleanup subcommand ---
if [[ $OPT_CLEANUP -eq 1 ]]; then
    if ! command -v fzf &>/dev/null; then
        echo "Error: fzf not found. Install fzf for interactive cleanup." >&2
        exit 1
    fi

    images=$(podman images --filter "reference=opencode-sandbox:*" --format "{{.Repository}}:{{.Tag}}\t{{.ID}}\t{{.Size}}\t{{.CreatedSince}}" 2>/dev/null || true)
    if [[ -z "$images" ]]; then
        echo "No sandbox images found."
        exit 0
    fi

    fzf_lines=""
    while IFS=$'\t' read -r name id size created; do
        fzf_lines+="$(printf "%-30s  %-14s  %-10s  %s" "$name" "$id" "$size" "$created")"$'\n'
    done <<< "$images"

    selected=$(echo "$fzf_lines" | fzf --multi --header="Select images to remove (TAB to multi-select, ENTER to confirm)" --reverse) || exit 0

    while IFS= read -r line; do
        image_name=$(echo "$line" | awk '{print $1}')
        [[ -z "$image_name" ]] && continue
        echo "Removing $image_name..."
        podman rmi "$image_name"
    done <<< "$selected"
    echo "Done."
    exit 0
fi

# --- Project containerfile discovery ---
# SANDBOX_CONTAINERFILE env override takes precedence (must exist).
# Otherwise: project overrides global, no concatenation.
if [[ -n "${SANDBOX_CONTAINERFILE:-}" ]]; then
    if [[ ! -f "$SANDBOX_CONTAINERFILE" ]]; then
        echo "Error: SANDBOX_CONTAINERFILE does not exist: $SANDBOX_CONTAINERFILE" >&2
        exit 1
    fi
    verbose "Containerfile: $SANDBOX_CONTAINERFILE (env override)"
elif [[ -f "$PROJECT_CONTAINERFILE" ]]; then
    SANDBOX_CONTAINERFILE="$PROJECT_CONTAINERFILE"
    verbose "Project containerfile: $PROJECT_CONTAINERFILE (project)"
elif [[ -f "$GLOBAL_CONTAINERFILE" ]]; then
    SANDBOX_CONTAINERFILE="$GLOBAL_CONTAINERFILE"
    verbose "Project containerfile: $GLOBAL_CONTAINERFILE (global)"
else
    SANDBOX_CONTAINERFILE=""
    verbose "No project containerfile, using default Ubuntu base"
fi
readonly SANDBOX_CONTAINERFILE

# --- CWD safety ---
if [[ $OPT_STATELESS -eq 0 ]]; then
    if [[ "$PWD" == "$HOME" ]]; then
        echo "Warning: running in \$HOME — this will mount your entire home directory." >&2
        read -rp "Continue? [y/N] " answer
        [[ "$answer" =~ ^[Yy]$ ]] || exit 1
    elif [[ "$PWD" != "$HOME"/* ]]; then
        echo "Warning: running outside \$HOME ($PWD)." >&2
        read -rp "Continue? [y/N] " answer
        [[ "$answer" =~ ^[Yy]$ ]] || exit 1
    fi
fi

# --- Auto-fallback: --opencode host (default) with no host binary -> install ---
if [[ "$OPT_OPENCODE_SOURCE" == "host" && "$OPT_OPENCODE_EXPLICIT" -eq 0 ]]; then
    if ! command -v opencode &>/dev/null; then
        echo "Note: opencode not found on host; falling back to --opencode install" >&2
        OPT_OPENCODE_SOURCE=install
    fi
fi
readonly OPT_OPENCODE_SOURCE

# --- Generate Containerfile, derive image tag ---
GENERATED_CONTAINERFILE="$(generate_containerfile)"
CONFIG_HASH=$(echo -n "$GENERATED_CONTAINERFILE" | sha256sum | cut -c1-10)
IMAGE_TAG="opencode-sandbox:$CONFIG_HASH"
readonly GENERATED_CONTAINERFILE CONFIG_HASH IMAGE_TAG

# --- Trust-gate if custom containerfile in use ---
if [[ -n "$SANDBOX_CONTAINERFILE" ]]; then
    ensure_config_trusted "$GENERATED_CONTAINERFILE"
fi

# --- Build if needed ---
if needs_rebuild; then
    echo "Building sandbox image ($IMAGE_TAG)..."
    verbose "Generated Containerfile:\n$GENERATED_CONTAINERFILE"
    EMPTY_CTX=$(mktemp -d "${XDG_RUNTIME_DIR:-/tmp}/opencode-sandbox-ctx-XXXXXX")
    echo "$GENERATED_CONTAINERFILE" | podman build \
        -t "$IMAGE_TAG" \
        -f - \
        "$EMPTY_CTX"
    rm -rf "$EMPTY_CTX"
fi

# --- Container name ---
CONTAINER_NAME="opencode-sandbox-$$"
readonly CONTAINER_NAME
verbose "Container name: $CONTAINER_NAME"

prepare_sandbox_home "$CONTAINER_NAME"

# --- Working directory ---
if [[ $OPT_STATELESS -eq 1 ]]; then
    WORKDIR="$HOME"
else
    WORKDIR="$PWD"
fi
readonly WORKDIR

# --- Run ---
RUN_ARGS=(
    --rm
    --name "$CONTAINER_NAME"
    --userns="keep-id:uid=$(id -u),gid=$(id -g)"
    --label "opencode-sandbox.project-dir=$PWD"
    -e OPENCODE_DISABLE_AUTOUPDATE=1
    -e TERM=xterm-256color
    -e COLORTERM
    -w "$WORKDIR"
    -it
    # Mask /proc paths that leak host info (kernel symbols, memory, mounts, scheduler)
    --security-opt mask=/proc/kcore:/proc/kallsyms:/proc/config.gz:/proc/sched_debug:/proc/timer_list:/proc/self/mountinfo:/proc/1/mountinfo
    # Hide other users' processes in /proc
    --security-opt proc-opts=hidepid=2
    # Drop all capabilities; users can re-add with --cap-add
    --cap-drop=ALL
    "${CAP_ADD_ARGS[@]}"
)

# Pass through provider API key env vars to the container.
# This allows configuring opencode with various LLM providers.
while IFS='=' read -r -d '' name _; do
    RUN_ARGS+=(-e "$name")
done < <(env -0 | grep -z -E '^(ANTHROPIC_|OPENAI_|GEMINI_|GROQ_|AWS_|AZURE_|OPENCODE_|GOOGLE_|GITLAB_|CLOUDFLARE_)')

# Pass through GITHUB_TOKEN if set
if [[ -n "${GITHUB_TOKEN:-}" ]]; then
    RUN_ARGS+=(-e GITHUB_TOKEN)
fi

# Build mount args directly into RUN_ARGS (avoids word-splitting issues with paths)
build_mounts

# --- Resolve and mount host opencode binary ---
if [[ "$OPT_OPENCODE_SOURCE" == "host" ]]; then
    OPENCODE_BIN=$(readlink -f "$(command -v opencode)" 2>/dev/null) || true
    if [[ -z "$OPENCODE_BIN" || ! -f "$OPENCODE_BIN" ]]; then
        echo "Error: opencode binary not found in PATH." >&2
        exit 1
    fi
    verbose "OpenCode binary: $OPENCODE_BIN"
    RUN_ARGS+=(-v "$OPENCODE_BIN:$HOME/.local/bin/opencode:ro,z")
fi

verbose "podman run ${RUN_ARGS[*]} $IMAGE_TAG opencode ${OPENCODE_ARGS[*]}"
exec podman run "${RUN_ARGS[@]}" "$IMAGE_TAG" opencode "${OPENCODE_ARGS[@]}"
